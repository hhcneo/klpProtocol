// Code generated by Thrift Compiler (0.19.0). DO NOT EDIT.

package protocol

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

type ForwardType int64
const (
  ForwardType_kMulticast ForwardType = 0
  ForwardType_kAnycast ForwardType = 1
)

func (p ForwardType) String() string {
  switch p {
  case ForwardType_kMulticast: return "kMulticast"
  case ForwardType_kAnycast: return "kAnycast"
  }
  return "<UNSET>"
}

func ForwardTypeFromString(s string) (ForwardType, error) {
  switch s {
  case "kMulticast": return ForwardType_kMulticast, nil 
  case "kAnycast": return ForwardType_kAnycast, nil 
  }
  return ForwardType(0), fmt.Errorf("not a valid ForwardType string")
}


func ForwardTypePtr(v ForwardType) *ForwardType { return &v }

func (p ForwardType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ForwardType) UnmarshalText(text []byte) error {
q, err := ForwardTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ForwardType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ForwardType(v)
return nil
}

func (p * ForwardType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type RemoveUserReason int64
const (
  RemoveUserReason_kInternal RemoveUserReason = 0
  RemoveUserReason_kSerializeFail RemoveUserReason = 1
  RemoveUserReason_kReconnectTimeout RemoveUserReason = 2
  RemoveUserReason_kFromUser RemoveUserReason = 3
  RemoveUserReason_kFromRoomContents RemoveUserReason = 4
  RemoveUserReason_kByPurgeRoom RemoveUserReason = 5
  RemoveUserReason_kDuplicated RemoveUserReason = 6
  RemoveUserReason_kWaitingFinish RemoveUserReason = 7
  RemoveUserReason_kLimitUserCount RemoveUserReason = 8
  RemoveUserReason_kInvalidState RemoveUserReason = 9
  RemoveUserReason_kUserDefined_0 RemoveUserReason = 1000
  RemoveUserReason_kUserDefined_1 RemoveUserReason = 1001
  RemoveUserReason_kUserDefined_2 RemoveUserReason = 1002
  RemoveUserReason_kUserDefined_3 RemoveUserReason = 1003
  RemoveUserReason_kUserDefined_4 RemoveUserReason = 1004
  RemoveUserReason_kUserDefined_5 RemoveUserReason = 1005
  RemoveUserReason_kUserDefined_6 RemoveUserReason = 1006
  RemoveUserReason_kUserDefined_7 RemoveUserReason = 1007
  RemoveUserReason_kUserDefined_8 RemoveUserReason = 1008
  RemoveUserReason_kUserDefined_9 RemoveUserReason = 1009
  RemoveUserReason_kUserDefinedMax RemoveUserReason = 1010
)

func (p RemoveUserReason) String() string {
  switch p {
  case RemoveUserReason_kInternal: return "kInternal"
  case RemoveUserReason_kSerializeFail: return "kSerializeFail"
  case RemoveUserReason_kReconnectTimeout: return "kReconnectTimeout"
  case RemoveUserReason_kFromUser: return "kFromUser"
  case RemoveUserReason_kFromRoomContents: return "kFromRoomContents"
  case RemoveUserReason_kByPurgeRoom: return "kByPurgeRoom"
  case RemoveUserReason_kDuplicated: return "kDuplicated"
  case RemoveUserReason_kWaitingFinish: return "kWaitingFinish"
  case RemoveUserReason_kLimitUserCount: return "kLimitUserCount"
  case RemoveUserReason_kInvalidState: return "kInvalidState"
  case RemoveUserReason_kUserDefined_0: return "kUserDefined_0"
  case RemoveUserReason_kUserDefined_1: return "kUserDefined_1"
  case RemoveUserReason_kUserDefined_2: return "kUserDefined_2"
  case RemoveUserReason_kUserDefined_3: return "kUserDefined_3"
  case RemoveUserReason_kUserDefined_4: return "kUserDefined_4"
  case RemoveUserReason_kUserDefined_5: return "kUserDefined_5"
  case RemoveUserReason_kUserDefined_6: return "kUserDefined_6"
  case RemoveUserReason_kUserDefined_7: return "kUserDefined_7"
  case RemoveUserReason_kUserDefined_8: return "kUserDefined_8"
  case RemoveUserReason_kUserDefined_9: return "kUserDefined_9"
  case RemoveUserReason_kUserDefinedMax: return "kUserDefinedMax"
  }
  return "<UNSET>"
}

func RemoveUserReasonFromString(s string) (RemoveUserReason, error) {
  switch s {
  case "kInternal": return RemoveUserReason_kInternal, nil 
  case "kSerializeFail": return RemoveUserReason_kSerializeFail, nil 
  case "kReconnectTimeout": return RemoveUserReason_kReconnectTimeout, nil 
  case "kFromUser": return RemoveUserReason_kFromUser, nil 
  case "kFromRoomContents": return RemoveUserReason_kFromRoomContents, nil 
  case "kByPurgeRoom": return RemoveUserReason_kByPurgeRoom, nil 
  case "kDuplicated": return RemoveUserReason_kDuplicated, nil 
  case "kWaitingFinish": return RemoveUserReason_kWaitingFinish, nil 
  case "kLimitUserCount": return RemoveUserReason_kLimitUserCount, nil 
  case "kInvalidState": return RemoveUserReason_kInvalidState, nil 
  case "kUserDefined_0": return RemoveUserReason_kUserDefined_0, nil 
  case "kUserDefined_1": return RemoveUserReason_kUserDefined_1, nil 
  case "kUserDefined_2": return RemoveUserReason_kUserDefined_2, nil 
  case "kUserDefined_3": return RemoveUserReason_kUserDefined_3, nil 
  case "kUserDefined_4": return RemoveUserReason_kUserDefined_4, nil 
  case "kUserDefined_5": return RemoveUserReason_kUserDefined_5, nil 
  case "kUserDefined_6": return RemoveUserReason_kUserDefined_6, nil 
  case "kUserDefined_7": return RemoveUserReason_kUserDefined_7, nil 
  case "kUserDefined_8": return RemoveUserReason_kUserDefined_8, nil 
  case "kUserDefined_9": return RemoveUserReason_kUserDefined_9, nil 
  case "kUserDefinedMax": return RemoveUserReason_kUserDefinedMax, nil 
  }
  return RemoveUserReason(0), fmt.Errorf("not a valid RemoveUserReason string")
}


func RemoveUserReasonPtr(v RemoveUserReason) *RemoveUserReason { return &v }

func (p RemoveUserReason) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *RemoveUserReason) UnmarshalText(text []byte) error {
q, err := RemoveUserReasonFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *RemoveUserReason) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = RemoveUserReason(v)
return nil
}

func (p * RemoveUserReason) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type UserLocationType int64
const (
  UserLocationType_kLobby UserLocationType = 1
  UserLocationType_kRoom UserLocationType = 2
)

func (p UserLocationType) String() string {
  switch p {
  case UserLocationType_kLobby: return "kLobby"
  case UserLocationType_kRoom: return "kRoom"
  }
  return "<UNSET>"
}

func UserLocationTypeFromString(s string) (UserLocationType, error) {
  switch s {
  case "kLobby": return UserLocationType_kLobby, nil 
  case "kRoom": return UserLocationType_kRoom, nil 
  }
  return UserLocationType(0), fmt.Errorf("not a valid UserLocationType string")
}


func UserLocationTypePtr(v UserLocationType) *UserLocationType { return &v }

func (p UserLocationType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *UserLocationType) UnmarshalText(text []byte) error {
q, err := UserLocationTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *UserLocationType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = UserLocationType(v)
return nil
}

func (p * UserLocationType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type RoomType int64
const (
  RoomType_kWaitTnmt RoomType = 1
  RoomType_kTnmtRound RoomType = 2
  RoomType_kNormal RoomType = 3
)

func (p RoomType) String() string {
  switch p {
  case RoomType_kWaitTnmt: return "kWaitTnmt"
  case RoomType_kTnmtRound: return "kTnmtRound"
  case RoomType_kNormal: return "kNormal"
  }
  return "<UNSET>"
}

func RoomTypeFromString(s string) (RoomType, error) {
  switch s {
  case "kWaitTnmt": return RoomType_kWaitTnmt, nil 
  case "kTnmtRound": return RoomType_kTnmtRound, nil 
  case "kNormal": return RoomType_kNormal, nil 
  }
  return RoomType(0), fmt.Errorf("not a valid RoomType string")
}


func RoomTypePtr(v RoomType) *RoomType { return &v }

func (p RoomType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *RoomType) UnmarshalText(text []byte) error {
q, err := RoomTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *RoomType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = RoomType(v)
return nil
}

func (p * RoomType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type TnmtUserState int64
const (
  TnmtUserState_kWaitTnmt TnmtUserState = 1
  TnmtUserState_kRound TnmtUserState = 2
  TnmtUserState_kWaitRound TnmtUserState = 3
  TnmtUserState_kExitTnmt TnmtUserState = 4
)

func (p TnmtUserState) String() string {
  switch p {
  case TnmtUserState_kWaitTnmt: return "kWaitTnmt"
  case TnmtUserState_kRound: return "kRound"
  case TnmtUserState_kWaitRound: return "kWaitRound"
  case TnmtUserState_kExitTnmt: return "kExitTnmt"
  }
  return "<UNSET>"
}

func TnmtUserStateFromString(s string) (TnmtUserState, error) {
  switch s {
  case "kWaitTnmt": return TnmtUserState_kWaitTnmt, nil 
  case "kRound": return TnmtUserState_kRound, nil 
  case "kWaitRound": return TnmtUserState_kWaitRound, nil 
  case "kExitTnmt": return TnmtUserState_kExitTnmt, nil 
  }
  return TnmtUserState(0), fmt.Errorf("not a valid TnmtUserState string")
}


func TnmtUserStatePtr(v TnmtUserState) *TnmtUserState { return &v }

func (p TnmtUserState) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *TnmtUserState) UnmarshalText(text []byte) error {
q, err := TnmtUserStateFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *TnmtUserState) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = TnmtUserState(v)
return nil
}

func (p * TnmtUserState) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type Ssn int32

func SsnPtr(v Ssn) *Ssn { return &v }

type Gsn int64

func GsnPtr(v Gsn) *Gsn { return &v }

type Buffer []byte

func BufferPtr(v Buffer) *Buffer { return &v }

type KlpProtocolBuffer []byte

func KlpProtocolBufferPtr(v KlpProtocolBuffer) *KlpProtocolBuffer { return &v }

type RoomId int64

func RoomIdPtr(v RoomId) *RoomId { return &v }

type CategoryId int32

func CategoryIdPtr(v CategoryId) *CategoryId { return &v }

type TnmtSrl int64

func TnmtSrlPtr(v TnmtSrl) *TnmtSrl { return &v }

type ServerType int32

func ServerTypePtr(v ServerType) *ServerType { return &v }

type MembershipType int32

func MembershipTypePtr(v MembershipType) *MembershipType { return &v }

type ClientRequestKey int32

func ClientRequestKeyPtr(v ClientRequestKey) *ClientRequestKey { return &v }

type GameTypeId string

func GameTypeIdPtr(v GameTypeId) *GameTypeId { return &v }

// Attributes:
//  - Ssn
//  - RoomID
//  - CategoryID
//  - RoomContentsData
type RoomInfo struct {
  Ssn Ssn `thrift:"ssn,1,required" db:"ssn" json:"ssn"`
  RoomID RoomId `thrift:"room_id,2,required" db:"room_id" json:"room_id"`
  CategoryID CategoryId `thrift:"category_id,3,required" db:"category_id" json:"category_id"`
  RoomContentsData Buffer `thrift:"room_contents_data,4,required" db:"room_contents_data" json:"room_contents_data"`
}

func NewRoomInfo() *RoomInfo {
  return &RoomInfo{}
}


func (p *RoomInfo) GetSsn() Ssn {
  return p.Ssn
}

func (p *RoomInfo) GetRoomID() RoomId {
  return p.RoomID
}

func (p *RoomInfo) GetCategoryID() CategoryId {
  return p.CategoryID
}

func (p *RoomInfo) GetRoomContentsData() Buffer {
  return p.RoomContentsData
}
func (p *RoomInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetSsn bool = false;
  var issetRoomID bool = false;
  var issetCategoryID bool = false;
  var issetRoomContentsData bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetSsn = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRoomID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetCategoryID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetRoomContentsData = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetSsn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ssn is not set"));
  }
  if !issetRoomID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RoomID is not set"));
  }
  if !issetCategoryID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CategoryID is not set"));
  }
  if !issetRoomContentsData{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RoomContentsData is not set"));
  }
  return nil
}

func (p *RoomInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Ssn(v)
  p.Ssn = temp
}
  return nil
}

func (p *RoomInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := RoomId(v)
  p.RoomID = temp
}
  return nil
}

func (p *RoomInfo)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := CategoryId(v)
  p.CategoryID = temp
}
  return nil
}

func (p *RoomInfo)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := Buffer(v)
  p.RoomContentsData = temp
}
  return nil
}

func (p *RoomInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RoomInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RoomInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ssn", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ssn: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Ssn)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ssn (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ssn: ", p), err) }
  return err
}

func (p *RoomInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "room_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:room_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RoomID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.room_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:room_id: ", p), err) }
  return err
}

func (p *RoomInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "category_id", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:category_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CategoryID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.category_id (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:category_id: ", p), err) }
  return err
}

func (p *RoomInfo) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "room_contents_data", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:room_contents_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RoomContentsData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.room_contents_data (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:room_contents_data: ", p), err) }
  return err
}

func (p *RoomInfo) Equals(other *RoomInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ssn != other.Ssn { return false }
  if p.RoomID != other.RoomID { return false }
  if p.CategoryID != other.CategoryID { return false }
  if bytes.Compare(p.RoomContentsData, other.RoomContentsData) != 0 { return false }
  return true
}

func (p *RoomInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RoomInfo(%+v)", *p)
}

func (p *RoomInfo) Validate() error {
  return nil
}
// Attributes:
//  - Type
//  - CategoryID
//  - RoomID
type UserLocation struct {
  Type UserLocationType `thrift:"type,1,required" db:"type" json:"type"`
  CategoryID CategoryId `thrift:"category_id,2,required" db:"category_id" json:"category_id"`
  RoomID RoomId `thrift:"room_id,3,required" db:"room_id" json:"room_id"`
}

func NewUserLocation() *UserLocation {
  return &UserLocation{}
}


func (p *UserLocation) GetType() UserLocationType {
  return p.Type
}

func (p *UserLocation) GetCategoryID() CategoryId {
  return p.CategoryID
}

func (p *UserLocation) GetRoomID() RoomId {
  return p.RoomID
}
func (p *UserLocation) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetType bool = false;
  var issetCategoryID bool = false;
  var issetRoomID bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetType = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetCategoryID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetRoomID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"));
  }
  if !issetCategoryID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CategoryID is not set"));
  }
  if !issetRoomID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RoomID is not set"));
  }
  return nil
}

func (p *UserLocation)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := UserLocationType(v)
  p.Type = temp
}
  return nil
}

func (p *UserLocation)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := CategoryId(v)
  p.CategoryID = temp
}
  return nil
}

func (p *UserLocation)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := RoomId(v)
  p.RoomID = temp
}
  return nil
}

func (p *UserLocation) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UserLocation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserLocation) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err) }
  return err
}

func (p *UserLocation) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "category_id", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:category_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CategoryID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.category_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:category_id: ", p), err) }
  return err
}

func (p *UserLocation) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "room_id", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:room_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RoomID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.room_id (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:room_id: ", p), err) }
  return err
}

func (p *UserLocation) Equals(other *UserLocation) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Type != other.Type { return false }
  if p.CategoryID != other.CategoryID { return false }
  if p.RoomID != other.RoomID { return false }
  return true
}

func (p *UserLocation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserLocation(%+v)", *p)
}

func (p *UserLocation) Validate() error {
  return nil
}
// Attributes:
//  - RoomID
//  - RoomListData
type RoomListInfo struct {
  RoomID RoomId `thrift:"room_id,1,required" db:"room_id" json:"room_id"`
  RoomListData Buffer `thrift:"room_list_data,2,required" db:"room_list_data" json:"room_list_data"`
}

func NewRoomListInfo() *RoomListInfo {
  return &RoomListInfo{}
}


func (p *RoomListInfo) GetRoomID() RoomId {
  return p.RoomID
}

func (p *RoomListInfo) GetRoomListData() Buffer {
  return p.RoomListData
}
func (p *RoomListInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRoomID bool = false;
  var issetRoomListData bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetRoomID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetRoomListData = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRoomID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RoomID is not set"));
  }
  if !issetRoomListData{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RoomListData is not set"));
  }
  return nil
}

func (p *RoomListInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := RoomId(v)
  p.RoomID = temp
}
  return nil
}

func (p *RoomListInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Buffer(v)
  p.RoomListData = temp
}
  return nil
}

func (p *RoomListInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RoomListInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RoomListInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "room_id", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:room_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.RoomID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.room_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:room_id: ", p), err) }
  return err
}

func (p *RoomListInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "room_list_data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:room_list_data: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.RoomListData); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.room_list_data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:room_list_data: ", p), err) }
  return err
}

func (p *RoomListInfo) Equals(other *RoomListInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.RoomID != other.RoomID { return false }
  if bytes.Compare(p.RoomListData, other.RoomListData) != 0 { return false }
  return true
}

func (p *RoomListInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RoomListInfo(%+v)", *p)
}

func (p *RoomListInfo) Validate() error {
  return nil
}
